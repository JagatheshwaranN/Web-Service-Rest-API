Web Service
===========

What?
=====
Software system designed to support the inter-operable machine-to-machine interaction over a network.

3 Keys
======
1. Designed for machine-to-machine [or Application-to-Application] interaction
2. Should be inter-operable (NOT platform dependent)
3. Should allow communication over a network.

How?
====
How does the data exchange between applications takes place?
The data exchange done via Request and Response mode.

How can we make the web services platform independent?
The important thing for a web service to be independent is, the request and response should also
be platform independent.

2 Popular Formats
=================
1. XML
2. JSON

How does the application X knows the format of Request & Response?
The answer is Service Definition. Every WebService should provide the service definition.
Service Definition takes about,
1. Request/Response Formats
2. Request Structure
3. Response Structure
4. Endpoint

Key Terminologies
=================
1. Request & Response
2. Message Exchange Format
   a. XML & JSON
3. Service Provider / Server
4. Service Consumer / Client
5. Service Definition
6. Transport 
   a. HTTP & MQ

1. Request & Response
=====================
Request - Input / Data sent from Application to WebService.
Response - Output / Data sent back from WebService to Application.

2. Message Exchange Format
==========================
   a. XML & JSON
The Request & Response are sent inform of Messages which is either in XML
or JSON format.

3. Service Provider / Server
============================
Server on which service is hosted.

4. Service Consumer / Client
============================
Application which requests the webservice.

5. Service Definition
=====================
The contract between the Service Provider & Service Consumer.

6. Transport 
============
   a. HTTP & MQ
HTTP - The communication takes place over the web.
MQ - The Service Requester place the request on the (Message) Queue and the Service Provider
would be listening on the Queue. Whenever requests comes in, it takes and proccess it. Create
the response and put it back to the Requester.

WebService Groups
=================
1. SOAP
2. Rest 

SOAP
====
SOAP [Simple Object Access Protocol] - Earlier Abbreviation. But no longer. Its just type of
webservice.

Characteristics
===============
1. Format
	a. SOAP XML Request
	b. SOAP XML Response
2. Transport
	a. SOAP over MQ
	b. SOAP over HTTP
3. Service Definition
	a. WSDL

A WSDL defines the followiings.
1. Endpoint
2. All Operations
3. Request Structure
4. Response Structure

The typical SOAP message has followings parts.
1. SOAP Envelope
2. SOAP Header
3. SOAP Body

Rest [Representational State Transfer]
====
Whenever we develop a RESTful webservices, we always focuses on / thinking about the Resources.
Resource
========
1. A resource has an URI (Uniform Resource Identifier).
2. A resource can have different formats as below.
	a. XML
	b. HTML
	c. JSON
	
Characteristics
===============
1. Data Exchange Format
	a. No Restriction. JSON is popular.
2. Transport
	a. Only HTTP
3. Service Definition
	NO standard. WADL/Swagger..
WADL - Web Application Development Language.

REST vs SOAP [Its not an Apple-to-Apple comparison]
============
1. Restriction vs Architectural Approach
2. Data Exchange Format
3. Service Definition
4. Transport
5. Ease of implementation

Spring Framework
================
1. Tight & Loose Coupling
2. IOC Container
3. Application Context
4. Component Scan
5. Dependency Injection
6. Spring Beans
7. Auto Wiring

Spring Terminologies
====================
@Component
==========
Class managed by Spring Framework

Dependency: SPGameRunner needs SPGameConsole Impl.
	SPGameConsole Impl(Ex: SPMarioGame) is a dependency of SPGameRunner.

ComponentScan
=============
Spring scans the packages. By default, it will take the current package.
We can also provide the packages to scan.
@ComponentScan({"com.qa.base", "com.qa.test"})

Dependency Injection
====================
Identify Beans, their dependencies and wire them together (provides IOC - Inversion of Control)

Spring Beans
============
An object managed by Spring Framework.

IoC Container
=============
Manages the life cycle of beans and dependencies.
Types
=====
1. ApplicationContext (Complex)
2. BeanFactory (Simple Features - Rarely used)

AutoWiring
==========
The process of wiring in dependencies for a Spring Bean.

@Primary - Is used when we have multiple components to give priority to run the component.

Spring Dependency Injection Types
=================================
Constructor Based - Dependencies are set by creating the Bean using its Constructor.
Setter Based - Dependencies are set by calling Setter methods on your beans.
Fields - No Setter / Constructor. Dependency is injected using reflection.

Spring Team recommends Constructor-based injection as dependencies are automatically set
when object is created.

Spring Modules
==============
Spring Framework is divided into modules.
1. Core: IoC Container etc
2. Testing: Mock Objects, Spring MVC Test etc
3. Data Access: Transactions, JDBC, JPA etc
4. Web Servlet: Spring MVC etc
5. Web Reactive: Spring WebFlux etc
6. Integration: JMS etc

Spring Pojects [Spring keeps evolving (REST API > Microservices > Cloud)
==============
Spring Boot: Most popular framework to build microservices.
Spring Cloud: Build cloud native applications.
Spring Data: Integrate the same way with different types of databases: NoSQL and Relational.
Spring Integration: Address challenges with integration with other applications.
Spring Security: Secure you web application or REST API or microservice.

World Before Spring Boot
========================
1. Complex dependency management
2. Complex configurations for Web applications [web.xml].
3. Complex Spring Configurations (Manage of Spring Beans) [Component Scan, View Resolver].
4. Non-functional Requirements - Logging, Error handling, and Monitoring.

SpringBoot Goals
================
1. Helps you build Production Ready apps Quickly.
	a. Build Quickly
		1. Spring Initializr
		2. Spring Boot Starter Projects
		3. Spring Boot Auto Configuration
		4. Spring Boot DevTools
	b. Be Production Ready
		1. Logging
		2. Different Configuration for Different Environments
			Profiles, ConfigurationProperties
		3. Monitoring (Spring Boot Actuator)

Spring Boot Starter Projects
============================
1. I need a lot of frameworks to build application features:
	a. Build a REST API: I need Spring, Spring MVC, Tomcat, JSON conversion..
	b. Write Unit Tests: I need Spring Test, Junit, Mockito,..
2. How can I group them and make it easy to build applications?
	a. Starters: Convenient dependency descriptors for different feature.
3. Spring Boot provides variety of Starter projects:
	a. Web Application & REST API - Spring Boot Starter Web (spring-webmvc,
	spring-web, spring-boot-starter-tomcat, spring-boot-starter-json)
	b. Unit Tests - Spring Boot Starter Test
	c. Talk to Database using JPA - Spring Boot Starter Data JPA
	d. Talk to Database using JDBC - Spring Boot Starter JDBC
	e. Secure your web application or REST API - Spring Boot Starter Security

Spring Boot Auto Configuration
==============================
Need lot of configuration to build Spring app:
-> Component Scan, DispatcherServlet, Data Sources, JSON Conversion..

How can it be Simplified?
=========================
Auto Configuration: Automated configuration for your app.
Decided based on:
	1. Which frameworks are in the Class Path?
	2. What is the existing configuration (Annotations etc)?
Example: Spring Boot Starter Web
1. DispatcherServlet
2. Embedded Servlet Container - Tomcat (EmbeddedWebServerFactoryCustomizerAutoConfiguration)
3. Default Error Pages (ErrorMvcAutoConfiguration)
4. Bean<->JSON (JacksonHttpMessageConvertersConfiguration)

Spring Boot DevTools
====================
1. Increase Developer Productivity
2. Why do you need to restart the server manually for every code change?
	a. Add DevTools dependency to your POM.xml, then for every change 
	server restarts automatically.
3. Remember: For POM.xml dependency changes, you will need to restart
   server manually.
 
Production Ready
================
Managing App. Configuration using Profiles

1. Applications have different environments: Dev, QA. Stage, Prod,..
2. Different environments need different configuration:
	a. Different Databases
	b. Different Web Services
3. How can you provide different configuration for different environments?
	a. Profiles: Environment specific configuration
	
Configuration Properties
=======================
To specify configurations for specific services / endpoints in application.properties.
Creat a config class for the same and have it has POJO style.
Add the below annotations
@ConfigurationProperties(prefix = "currency-service")
@Component
Then create a controller class and invoke the config class.

Simplify Deployment with Spring Boot Embedded Servers
=====================================================
1. How do you deploy your application?
	a. Install Java
	b. Install Web/Application Server [Tomcat/WebSphere/WebLogic etc]
	c. Deploy the application WAR (Web Archive)
		This is the OLD WAR approach
		Complex to setup
2. Embedded Server - Simpler Alternative
	a. Install Java
	b. Run JAR file
	c. Make JAR not WAR
	d. Embedded Server Examples
		1. spring-boot-starter-tomcat
		2. spring-boot-starter-jetty
		3. spring-boot-starter-undertow

Monitoring Apps - Spring Boot Actuator
======================================
1. Monitor and manage your application in your production.
2. Provides a number of endpoints:
	a. beans - Complete list of Spring beans in your app.
	b. health - Application health information
	c. metrics - Application metrics.
	d. mappings - Details around Request Mappings.

Add the Spring Boot Starter Actuator dependency to your POM.xml
Navigate to http://localhost:8080/actuator
By default, it will show health endpoint only.

To have other endpoints, add it in your application.properties

Understanding Spring Boot Vs Spring MVC vs Spring
=================================================
Spring Boot vs Spring MVC vs Spring - What's in it?
1. Spring Framework: Dependency Injection.
	a. @Component, @AutoWired, Component Scan, etc..
	b. Just Dependency Injection is NOT sufficient (You need other frameworks to build apps)
		1. Spring Modules and Spring Projects: Extend Spring Eco System
			a. Provide good integration with other frameworks(Hibernate/JPA, JUnit & Mickito for Unit Testing)

2. Spring MVC (Spring Module): Simplify building web apps and REST API
	a. Building web applications with structs was very complex
	b. @Controller, @RestController, @RequestMapping("/endpoint")

3. Spring Boot (Spring Project): Build PRODUCTION-READY apps QUICKLY
	a. Starter Projects - Make it easy to build variety of apps.
	b. Auto Configuration - Eliminate configuration to setup Spring, Spring MVC, and other frameworks!
	c. Enable non-functional requirements:
		1. Actuator: Enables Advanced Monitoring of applications.
		2. Embedded Server: No need for separate application servers!
		3. Logging and Error Handling
		4. Profiles and ConfigurationProperties

Explore POM.xml
===============
1. Let's explore Project Object Model - pom.xml
	a. Maven dependencies: Frameworks & Libraries used in a project.
		1. Example: spring-boot-starter-web & spring-boot-starter-test
		Why are there so many dependencies in the Classpath?
			a. Answer: Transitive Dependencies.
			b. Remember - Spring Dependencies are Different.
	b. Maven Build -> help:effective-pom
	c. Parent POM: spring-boot-starter-parent
		1. Dependency Management
		2. Properties: java.version, plugins, and configurations
	d. Name of our project: groupId + artifactId
		1. groupId: Similar to package name
		2. artifactId: Similar to class name
		
2. Activity: help:effective-pom, dependency:tree, & Eclipse UI

Maven Build LifeCycle
=====================
1. Build LifeCycle is a sequence of steps.
	a. Validate
	b. Compile
	c. Test
	d. Package
	e. Integration Test
	f. Verify
	g. Install
	h. Deploy

How does Maven works?
=====================
1. Maven follows Convention over Configuration.
	a. Pre defined folder structure
	b. Almost all Java projects follow Maven structure (Consistency)
2. Maven Central Repository contains jars (and others) indexed by artifactId
   and groupId.
	a. Stores all the versions of dependencies.
	b. repositories > repository
	c. pluginRepositories > pluginRepository
3. When a dependency is added to POM.xml, Maven tries to download the dependency
	a. Downloaded dependencies are stored inside your maven local repository.
	b. Local Repository: a temp folder on your machine where maven stores the 
	   jar and dependency files that are downloaded from Maven Repository.

Important Maven Commands
========================
1. mvn --version
2. mvn compile: Compile source files
3. mvn test-compile: Compile test files
	a. Observe Carefully: This will also compile source
4. mvn clean: Delete target directory
5. mvn test: Run unit tests
6. mvn package: Create a jar
7. mvn help:effective-pom
8. mvn dependency:tree

Spring Versions
===============
1. Version Scheme - MAJOR.MINOR.PATCH[-MODIFIER]
	a. Major: Significant amount of work to upgrade (10.0.0 to 11.0.0)
	b. Minor: Little to no work to upgrade (10.1.0 to 10.2.0)
	c. Patch: No work to upgrade (10.5.4 to 10.5.5)
	d. Modifier: Optional Modifier.

Gradle
======
1. Goal: Build, automate and deliver better software, faster.
	a. Build Anything: Cross-Platform Tool
		1. Java, C/C++, JavaScript, Python,..
	b. Automate Everything: Completely Programmable
		1. Complete flexibility
		2. Uses a DSL [Supports Groovy & Kotlin]
	c. Deliver Faster: Blazing-fast builds
		1. Compile avoidance to advanced caching
		2. Can speed up Maven builds by up to 90%
			a. Incrementality - Gradle runs only what is necessary
			   Example: Compiles only changed files.
			b. Build Cache - Reuses the build outputs of other Gradle builds with same inputs.
2. Same Project layout as Maven.
3. IDE support is still evolving.

Top 3 Java Plugins for Gradle:
	1. Java Plugin: Java compilation + testing + bundling capabilities
		a. Default layout
			1. src/main/java
			2. src/main/resources
			3. src/test/java
			4. src/test/resources
		b. Key task: Build
		Go to Eclipse -> Run Configuration -> Choose Gradle Task -> Rename it.
		Add task and name it as build, Apply and Run. Bin and Build folders
		will be created after succesful build run.
	2. Dependency Management: Maven-like dependency management
		a. group: 'org.springframework', name:'spring-core', version:'10.0.3.RELEASE'
		or Shortcut:'org.springframework:spring-core:10.0.3.RELEASE'
	3. Spring Boot Gradle Plugin: Spring Boot Support in Gradle
		a. Package executable SpringBoot jar, Container Image (bootJar, bootBuildImage)
		b. Use dependency management enabled by spring-boot-dependencies
			1. No need to specify dependency version
			Example: Implementation('org.springframework.boot:spring-boot-starter')
		
Soap Project Creation
=====================
Step 1
======
https://start.spring.io/

1. Select Spring Milestone version and Maven
2. Provide Group Id & Artifact Id
3. Add dependencies - Spring Web Services, JPA, and H2
4. Click on Generate button

Step 2
======
Import the extracted project into Eclipse.

Step 3
======
Create simple SOAP Web Service using Spring Web Service.

Here, we need a Web Service Client and Web Service Provider. The communication between them 
is done using SOAP Messages.

Things to implement
===================
1. Service Definition 
	a. XML
	b. XSD
	c. WSDL [Generated using Spring Web Service]
2. XML Java Binding [ To convert the incoming SOAP message into Object.Also, send the Response Object
   back in SOAP message format.
	a. JAXB
3. Framework Configuration
	a. Endpoint
	b. WSDL-Generation
4. SOAP Web Service Client
	a. Wizdler Chrome Plugin
	

Soap Web Service Starter Project Setup
======================================
1. Created Request & Response structure using .xml file.
2. Created XSD for Request and Response.
3. Updated POM.xml file with JAXB2 Maven plugin.
	a. JAXB plugin used to converted the XSD created into Java Object.
	b. XSD file should be placed inside the src/main/resources.
	c. Java Source Folder should be selected as src/main/java.
	d. Clear Folder option should be FALSE. Otherwise, it will clear src/main/java folder.
4. Reference - https://www.mojohaus.org/jaxb2-maven-plugin/Documentation/v2.4/example_xjc_basic.html
5. After updating the plugin, it will generate the java class files.
6. Create a Endpoint class and map the configurations for Request, and Response.
7. Create WebServiceConfig class file and created the ServlerRegistationBean method to Register
   MessageDispatcherServlet and mapped the Endpoint to the Servlet.
8. Next, using the xsd file, we need to create the WSDL file in /ws/course.wsdl
9. 2 Things needed is PortType and NameSpace.
10. Created XsdSchema to mention the schema file.
11. DefaultWsdlDefinition created with Port, Namespace, URI, and Schema details. 
12. Added wsdl4j dependency in POM.xml file.
13. Run the Project and got the URI specified. [localhost:8080/ws/courses.wsdl]
14. Installed Boomerang Extension. Executed the First SOAP Web Service.








	
		


































